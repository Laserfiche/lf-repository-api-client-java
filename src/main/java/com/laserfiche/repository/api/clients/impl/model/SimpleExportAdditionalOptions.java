/*
 * Laserfiche Repository API
 * Welcome to the Laserfiche API Swagger Playground. You can try out any of our API calls against your live Laserfiche Cloud account. Visit the developer center for more details: <a href=\"https://developer.laserfiche.com\">https://developer.laserfiche.com</a><p><strong>Build# : </strong>eb72c77d640efc5f986310ccc43114fc25742dab_.20220610.1</p>
 *
 * OpenAPI spec version: 2-alpha
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.laserfiche.repository.api.clients.impl.model;

import com.google.gson.annotations.SerializedName;
import io.swagger.v3.oas.annotations.media.Schema;

import java.util.Objects;

/**
 * SimpleExportAdditionalOptions
 */

public class SimpleExportAdditionalOptions {
  @SerializedName("jpegCompression")
  private Integer jpegCompression = 70;

  @SerializedName("exportImageIncludeAnnotations")
  private Boolean exportImageIncludeAnnotations = true;

  @SerializedName("exportImageConvertPdfAnnotations")
  private Boolean exportImageConvertPdfAnnotations = true;

  @SerializedName("exportImageMultipageTiff")
  private Boolean exportImageMultipageTiff = true;

  @SerializedName("exportImagePagePrefix")
  private String exportImagePagePrefix = ", Page ";

  @SerializedName("exportImageIncludeRedacts")
  private Boolean exportImageIncludeRedacts = true;

  @SerializedName("exportTextRedactChar")
  private String exportTextRedactChar = "X";

  @SerializedName("watermark")
  private SimpleExportWatermark watermark = null;

  public SimpleExportAdditionalOptions jpegCompression(Integer jpegCompression) {
    this.jpegCompression = jpegCompression;
    return this;
  }

   /**
   * The JPEG compression quality when part&#x3D;Pages. The value must be between 0 and 100 (inclusive).
   * @return jpegCompression
  **/
  @Schema(description = "The JPEG compression quality when part=Pages. The value must be between 0 and 100 (inclusive).")
  public Integer getJpegCompression() {
    return jpegCompression;
  }

  public void setJpegCompression(Integer jpegCompression) {
    this.jpegCompression = jpegCompression;
  }

  public SimpleExportAdditionalOptions exportImageIncludeAnnotations(Boolean exportImageIncludeAnnotations) {
    this.exportImageIncludeAnnotations = exportImageIncludeAnnotations;
    return this;
  }

   /**
   * Determines whether or not the annotations need to be included when part&#x3D;Pages. If true, annotations are included, otherwise they are not.
   * @return exportImageIncludeAnnotations
  **/
  @Schema(description = "Determines whether or not the annotations need to be included when part=Pages. If true, annotations are included, otherwise they are not.")
  public Boolean isExportImageIncludeAnnotations() {
    return exportImageIncludeAnnotations;
  }

  public void setExportImageIncludeAnnotations(Boolean exportImageIncludeAnnotations) {
    this.exportImageIncludeAnnotations = exportImageIncludeAnnotations;
  }

  public SimpleExportAdditionalOptions exportImageConvertPdfAnnotations(Boolean exportImageConvertPdfAnnotations) {
    this.exportImageConvertPdfAnnotations = exportImageConvertPdfAnnotations;
    return this;
  }

   /**
   * Determines whether or not the annotations need to be converted when part&#x3D;Pages. If true, annotations are converted, otherwise they are not.
   * @return exportImageConvertPdfAnnotations
  **/
  @Schema(description = "Determines whether or not the annotations need to be converted when part=Pages. If true, annotations are converted, otherwise they are not.")
  public Boolean isExportImageConvertPdfAnnotations() {
    return exportImageConvertPdfAnnotations;
  }

  public void setExportImageConvertPdfAnnotations(Boolean exportImageConvertPdfAnnotations) {
    this.exportImageConvertPdfAnnotations = exportImageConvertPdfAnnotations;
  }

  public SimpleExportAdditionalOptions exportImageMultipageTiff(Boolean exportImageMultipageTiff) {
    this.exportImageMultipageTiff = exportImageMultipageTiff;
    return this;
  }

   /**
   * Determines whether exporting to TIFF should result in a single multi-page TIFF file, or in multiple single-page TIFF files (in a single Zip file), when part&#x3D;Pages. If true, a single multi-page file is generated, otherwise, multiple single-page files are generated.
   * @return exportImageMultipageTiff
  **/
  @Schema(description = "Determines whether exporting to TIFF should result in a single multi-page TIFF file, or in multiple single-page TIFF files (in a single Zip file), when part=Pages. If true, a single multi-page file is generated, otherwise, multiple single-page files are generated.")
  public Boolean isExportImageMultipageTiff() {
    return exportImageMultipageTiff;
  }

  public void setExportImageMultipageTiff(Boolean exportImageMultipageTiff) {
    this.exportImageMultipageTiff = exportImageMultipageTiff;
  }

  public SimpleExportAdditionalOptions exportImagePagePrefix(String exportImagePagePrefix) {
    this.exportImagePagePrefix = exportImagePagePrefix;
    return this;
  }

   /**
   * The page prefix of the individual files, when exporting to multi-file format (e.g.zip) when part&#x3D;Pages. The value must have a length of atmost 10 characters.  Further, as the value is used in the file name, it cannot include characters that are invalid from the point of view of the file system. These invalid characters are: colon (:), slash, backslash, double-quotation, asterisk, question mark, Angle brackets(i.e. less than, greater than), and vertical bar (|) An empty string or all-whitespace string is allowed.
   * @return exportImagePagePrefix
  **/
  @Schema(description = "The page prefix of the individual files, when exporting to multi-file format (e.g.zip) when part=Pages. The value must have a length of atmost 10 characters.  Further, as the value is used in the file name, it cannot include characters that are invalid from the point of view of the file system. These invalid characters are: colon (:), slash, backslash, double-quotation, asterisk, question mark, Angle brackets(i.e. less than, greater than), and vertical bar (|) An empty string or all-whitespace string is allowed.")
  public String getExportImagePagePrefix() {
    return exportImagePagePrefix;
  }

  public void setExportImagePagePrefix(String exportImagePagePrefix) {
    this.exportImagePagePrefix = exportImagePagePrefix;
  }

  public SimpleExportAdditionalOptions exportImageIncludeRedacts(Boolean exportImageIncludeRedacts) {
    this.exportImageIncludeRedacts = exportImageIncludeRedacts;
    return this;
  }

   /**
   * Determines whether or not the redactions need to be included. If true, redactions are included, otherwise they are not. This is applicable when part&#x3D;Pages or part&#x3D;Text.
   * @return exportImageIncludeRedacts
  **/
  @Schema(description = "Determines whether or not the redactions need to be included. If true, redactions are included, otherwise they are not. This is applicable when part=Pages or part=Text.")
  public Boolean isExportImageIncludeRedacts() {
    return exportImageIncludeRedacts;
  }

  public void setExportImageIncludeRedacts(Boolean exportImageIncludeRedacts) {
    this.exportImageIncludeRedacts = exportImageIncludeRedacts;
  }

  public SimpleExportAdditionalOptions exportTextRedactChar(String exportTextRedactChar) {
    this.exportTextRedactChar = exportTextRedactChar;
    return this;
  }

   /**
   * The redaction character, i.e. the character that replaces the original character in a redacted text.  This is applicable when part&#x3D;Pages or part&#x3D;Text. The value must be a string of length 1. Empty or all-whitespace string is not allowed.
   * @return exportTextRedactChar
  **/
  @Schema(description = "The redaction character, i.e. the character that replaces the original character in a redacted text.  This is applicable when part=Pages or part=Text. The value must be a string of length 1. Empty or all-whitespace string is not allowed.")
  public String getExportTextRedactChar() {
    return exportTextRedactChar;
  }

  public void setExportTextRedactChar(String exportTextRedactChar) {
    this.exportTextRedactChar = exportTextRedactChar;
  }

  public SimpleExportAdditionalOptions watermark(SimpleExportWatermark watermark) {
    this.watermark = watermark;
    return this;
  }

   /**
   * The watermark element added to the pages when Part&#x3D;Pages.
   * @return watermark
  **/
  @Schema(description = "The watermark element added to the pages when Part=Pages.")
  public SimpleExportWatermark getWatermark() {
    return watermark;
  }

  public void setWatermark(SimpleExportWatermark watermark) {
    this.watermark = watermark;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SimpleExportAdditionalOptions simpleExportAdditionalOptions = (SimpleExportAdditionalOptions) o;
    return Objects.equals(this.jpegCompression, simpleExportAdditionalOptions.jpegCompression) &&
        Objects.equals(this.exportImageIncludeAnnotations, simpleExportAdditionalOptions.exportImageIncludeAnnotations) &&
        Objects.equals(this.exportImageConvertPdfAnnotations, simpleExportAdditionalOptions.exportImageConvertPdfAnnotations) &&
        Objects.equals(this.exportImageMultipageTiff, simpleExportAdditionalOptions.exportImageMultipageTiff) &&
        Objects.equals(this.exportImagePagePrefix, simpleExportAdditionalOptions.exportImagePagePrefix) &&
        Objects.equals(this.exportImageIncludeRedacts, simpleExportAdditionalOptions.exportImageIncludeRedacts) &&
        Objects.equals(this.exportTextRedactChar, simpleExportAdditionalOptions.exportTextRedactChar) &&
        Objects.equals(this.watermark, simpleExportAdditionalOptions.watermark);
  }

  @Override
  public int hashCode() {
    return Objects.hash(jpegCompression, exportImageIncludeAnnotations, exportImageConvertPdfAnnotations, exportImageMultipageTiff, exportImagePagePrefix, exportImageIncludeRedacts, exportTextRedactChar, watermark);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SimpleExportAdditionalOptions {\n");
    
    sb.append("    jpegCompression: ").append(toIndentedString(jpegCompression)).append("\n");
    sb.append("    exportImageIncludeAnnotations: ").append(toIndentedString(exportImageIncludeAnnotations)).append("\n");
    sb.append("    exportImageConvertPdfAnnotations: ").append(toIndentedString(exportImageConvertPdfAnnotations)).append("\n");
    sb.append("    exportImageMultipageTiff: ").append(toIndentedString(exportImageMultipageTiff)).append("\n");
    sb.append("    exportImagePagePrefix: ").append(toIndentedString(exportImagePagePrefix)).append("\n");
    sb.append("    exportImageIncludeRedacts: ").append(toIndentedString(exportImageIncludeRedacts)).append("\n");
    sb.append("    exportTextRedactChar: ").append(toIndentedString(exportTextRedactChar)).append("\n");
    sb.append("    watermark: ").append(toIndentedString(watermark)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
